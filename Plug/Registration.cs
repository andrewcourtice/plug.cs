using Plug.Core;
using Plug.Exceptions;
using Plug.Factories;
using Plug.Helpers;
using System;
using System.Linq;

namespace Plug
{
    /// <summary>
    /// Base registration type to store in generic lists
    /// </summary>
    public class Registration
    {
        private readonly Scope scope;
        private object instance;
        private DateTime lastResolutionDate;

        /// <summary>
        /// The factory responsible for resolving this registration
        /// </summary>
        public IFactory Factory { get; }

        public AppDomain Domain
        {
            get { return scope != null ? scope.Domain : AppDomain.CurrentDomain; }
        }

        /// <summary>
        /// A boxed reference to the current instance of the dependency
        /// </summary>
        public InstanceConstructor InstanceConstructor { get; }

        /// <summary>
        /// The type of this registration (the type of the interface)
        /// </summary>
        public Type RegistrationType { get; }

        /// <summary>
        /// The instance type of this registration
        /// </summary>
        public Type InstanceType { get; }

        /// <summary>
        /// The time (UTC) the last instance was resolved
        /// </summary>
        public DateTime LastResolutionDate
        {
            get { return lastResolutionDate; }
        }

        public bool HasInstance
        {
            get { return instance != null; }
        }

        /// <summary>
        /// A class to store information about a dependency
        /// </summary>
        /// <param name="instanceType">The instance type of this registration</param>
        /// <param name="factory">The factory responsible for resolving this registration</param>
        public Registration(Type registrationType, Type instanceType, IFactory factory)
        {
            Validator.ValidateRegistration(registrationType, instanceType, factory);

            Factory = factory;
            RegistrationType = registrationType;
            InstanceType = instanceType;

            InstanceConstructor = factory.GenerateInstanceConstructor(this);
        }

        /// <summary>
        /// Resolve a nested dependency
        /// </summary>
        /// <param name="container">The container to search dependencies for</param>
        /// <param name="parameterType"></param>
        /// <returns></returns>
        private object ResolveDependency(Container container, Type parameterType)
        {
            // If the parameter is the same type as this registration bail out
            // to prevent circular dependencies from recursively resolving
            if (parameterType == RegistrationType)
            {
                return null;
            }

            // If the type isn't registered a 'NotRegisteredException' will occur here
            // Not necessary to catch the exception. If deep resolution is enabled and the 
            // dependency isn't registered, the caller should be expecting the exception 
            // to propagate through
            return container.Resolve(parameterType);
        }

        /// <summary>
        /// Resolve any nested dependencies required in the constructor of the instance of this registration
        /// </summary>
        /// <param name="container">The container to search dependencies for</param>
        /// <returns></returns>
        private object[] ResolveDependencies(Container container)
        {
            var instanceConstructor = InstanceType.GetConstructors().First();
            var constructorParameters = instanceConstructor.GetParameters();

            var resolvedParameters = new object[constructorParameters.Length];

            if (container.Configuration.DeepResolution)
            {
                for (var i = 0; i < constructorParameters.Length; i++)
                {
                    var constructorParameter = constructorParameters[i];
                    var parameterType = constructorParameter.ParameterType;

                    resolvedParameters[i] = ResolveDependency(container, parameterType);
                }
            }

            return resolvedParameters;
        }

        /// <summary>
        /// Resolve an instance of this registration
        /// </summary>
        /// <returns>The instance of the registration generated by the assigned factory</returns>
        public object Resolve(Container container)
        {
            var args = ResolveDependencies(container);
            var resolution = Factory.Resolve(this, args);

            if (resolution != null)
            {
                instance = resolution;
            }

            lastResolutionDate = DateTime.UtcNow;

            Validator.ValidateInstance(instance, RegistrationType, InstanceType, container.Configuration.StrictMode);

            return instance;
        }

        /// <summary>
        /// If the instance implements a disposal pattern, call the dispose method
        /// to cleanup any unmanaged resources attached to the instance
        /// </summary>
        ~Registration()
        {
            if (instance != null && instance is IDisposable)
            {
                ((IDisposable) instance).Dispose();
            }
        }
    }
}
