using Plug.Core;
using Plug.Factories;
using Plug.Helpers;
using System;
using System.Linq;

namespace Plug
{
    /// <summary>
    /// Base registration type to store in generic lists
    /// </summary>
    public class Registration
    {
        private object instance;

        /// <summary>
        /// The factory responsible for resolving this registration
        /// </summary>
        public IFactory Factory { get; }

        /// <summary>
        /// The type of this registration (the type of the interface)
        /// </summary>
        public Type RegistrationType { get; }

        public InstanceConstructor InstanceConstructor { get; private set; }

        /// <summary>
        /// The instance type of this registration
        /// </summary>
        public Type InstanceType { get; private set; }

        /// <summary>
        /// A boxed reference to the current instance of the dependency
        /// </summary>
        public object Instance
        {
            get
            {
                return instance;
            }
            private set
            {
                instance = value;
                LastResolutionDate = DateTime.UtcNow;
            }
        }

        /// <summary>
        /// The time (UTC) the last instance was resolved
        /// </summary>
        public DateTime LastResolutionDate { get; private set; }

        public bool HasInstance
        {
            get { return Instance != null; }
        }

        public void Update(Type instanceType)
        {
            Validator.ValidateRegistration(RegistrationType, instanceType, Factory);

            InstanceType = instanceType;
            InstanceConstructor = Factory.GenerateInstanceConstructor(this);
        }

        /// <summary>
        /// A class to store information about a dependency
        /// </summary>
        /// <param name="instanceType">The instance type of this registration</param>
        /// <param name="factory">The factory responsible for resolving this registration</param>
        public Registration(Type registrationType, Type instanceType, IFactory factory)
        {
            Factory = factory;
            RegistrationType = registrationType;

            Update(instanceType);
        }

        /// <summary>
        /// Resolve a nested dependency
        /// </summary>
        /// <param name="container">The container to search dependencies for</param>
        /// <param name="parameterType"></param>
        /// <returns></returns>
        private object ResolveDependency(Container container, Type parameterType)
        {
            // If the parameter is the same type as this registration bail out
            // to prevent circular dependencies from recursively resolving
            if (parameterType == RegistrationType)
            {
                return null;
            }

            // If the type isn't registered a 'NotRegisteredException' will occur here
            // Not necessary to catch the exception. If deep resolution is enabled and the 
            // dependency isn't registered, the caller should be expecting the exception 
            // to propagate through
            return container.Resolve(parameterType);
        }

        /// <summary>
        /// Resolve any nested dependencies required in the constructor of the instance of this registration
        /// </summary>
        /// <param name="container">The container to search dependencies for</param>
        /// <returns></returns>
        private object[] ResolveDependencies(Container container)
        {
            var constructorInfo = InstanceType.GetConstructors().First();
            var constructorParameters = constructorInfo.GetParameters();

            var resolvedParameters = new object[constructorParameters.Length];

            if (container.Configuration.DeepResolution)
            {
                for (var i = 0; i < constructorParameters.Length; i++)
                {
                    var constructorParameter = constructorParameters[i];
                    var parameterType = constructorParameter.ParameterType;

                    resolvedParameters[i] = ResolveDependency(container, parameterType);
                }
            }

            return resolvedParameters;
        }

        /// <summary>
        /// Resolve an instance of this registration
        /// </summary>
        /// <returns>The instance of the registration generated by the assigned factory</returns>
        public object Resolve(Container container)
        {
            var args = ResolveDependencies(container);
            var resolution = Factory.Resolve(this, args);

            if (resolution != null)
            {
               Instance = resolution;
            }

            Validator.ValidateInstance(Instance, RegistrationType, InstanceType, container.Configuration.StrictMode);

            return Instance;
        }

        /// <summary>
        /// If the instance implements a disposal pattern, call the dispose method
        /// to cleanup any unmanaged resources attached to the instance
        /// </summary>
        ~Registration()
        {
            if (instance != null && instance is IDisposable)
            {
                ((IDisposable) instance).Dispose();
            }
        }
    }
}
