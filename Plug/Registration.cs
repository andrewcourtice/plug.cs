using Plug.Core;
using Plug.Factories;
using Plug.Helpers;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace Plug
{
    /// <summary>
    /// Base registration type to store in generic lists
    /// </summary>
    public class Registration : MarshalByRefObject
    {
        private object instance;

        public Container Container { get; }

        /// <summary>
        /// The factory responsible for resolving this registration
        /// </summary>
        public IFactory Factory { get; }

        /// <summary>
        /// The type of this registration (the type of the interface)
        /// </summary>
        public Type RegistrationType { get; }

        public InstanceConstructor InstanceConstructor { get; private set; }

        /// <summary>
        /// The instance type of this registration
        /// </summary>
        public Type InstanceType { get; private set; }

        /// <summary>
        /// A boxed reference to the current instance of the dependency
        /// </summary>
        public object Instance
        {
            get
            {
                return instance;
            }
            private set
            {
                instance = value;
                LastResolutionDate = DateTime.UtcNow;
            }
        }

        /// <summary>
        /// The time (UTC) the last instance was resolved
        /// </summary>
        public DateTime LastResolutionDate { get; private set; }

        public bool HasInstance
        {
            get { return Instance != null; }
        }

        public void Update(Type instanceType)
        {
            InstanceType = instanceType;

            Validator.ValidateRegistration(this);

            InstanceConstructor = Factory.GenerateInstanceConstructor(this);
        }

        /// <summary>
        /// A class to store information about a dependency
        /// </summary>
        /// <param name="instanceType">The instance type of this registration</param>
        /// <param name="factory">The factory responsible for resolving this registration</param>
        public Registration(Type registrationType, Type instanceType, IFactory factory, Container container)
        {
            Container = container;
            Factory = factory;
            RegistrationType = registrationType;

            Update(instanceType);
        }

        /// <summary>
        /// Resolve any nested dependencies required in the constructor of the instance of this registration
        /// </summary>
        /// <param name="container">The container to search dependencies for</param>
        /// <returns></returns>
        private object[] ResolveDependencies()
        {
            var constructorInfo = InstanceType.GetConstructors().First();
            var constructorParameters = constructorInfo.GetParameters();

            var resolvedParameters = new object[constructorParameters.Length];

            if (Container.Configuration.DeepResolution)
            {
                for (var i = 0; i < constructorParameters.Length; i++)
                {
                    var constructorParameter = constructorParameters[i];
                    var parameterType = constructorParameter.ParameterType;

                    resolvedParameters[i] = Container.Resolve(parameterType);
                }
            }

            return resolvedParameters;
        }

        public IEnumerable<Registration> GetDependencies()
        {
            var constructorInfo = InstanceType.GetConstructors().First();
            var constructorParameters = constructorInfo.GetParameters();

            var dependencies = Container.Registrations.Join(constructorParameters, o => o.RegistrationType, i => i.ParameterType, (o, i) => o);

            return dependencies;
        }

        /// <summary>
        /// Resolve an instance of this registration
        /// </summary>
        /// <returns>The instance of the registration generated by the assigned factory</returns>
        public object Resolve()
        {
            var args = ResolveDependencies();
            var resolution = Factory.Resolve(this, args);

            if (resolution != null)
            {
               Instance = resolution;
            }

            Validator.ValidateInstance(Instance, RegistrationType, InstanceType, Container.Configuration.StrictMode);

            return Instance;
        }

        /// <summary>
        /// If the instance implements a disposal pattern, call the dispose method
        /// to cleanup any unmanaged resources attached to the instance
        /// </summary>
        ~Registration()
        {
            if (instance != null && instance is IDisposable)
            {
                ((IDisposable) instance).Dispose();
            }
        }
    }
}
